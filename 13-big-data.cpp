#include <iostream>
#include <vector>

using std::cout;
using std::vector;

// 大数据题目一定出现在面试过程中, 所以取决于和面试管的聊天
// 因此在聊天的时候一定要问清楚资源限制, 例如是否允许误报, 是否允许使用额外的文件...
// 从而把握面试官想要考的到底是那个方法

// 大数据题目的解题技巧一共有七个, 不可能出现其他的技巧:
//  1）哈希函数可以把数据按照种类均匀分流 (万能方法)
//  2）布隆过滤器用于集合的建立与查询，并可以节省大量空间
//  3）一致性哈希解决数据服务器的负载管理问题
//  4）利用并查集结构做岛问题的并行计算
//  5）位图解决某一范围上数字的出现情况，并可以节省大量空间
//  6）利用分段统计思想、并进一步节省大量空间
//  7）利用堆、外排序来做多个处理单元的结果合并
// 之前的课已经介绍过前4个内容，本节内容为介绍解决大数据题目的后3个技巧大数据题目的解题技巧


class HashRedirect {
	// 有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
	// 【补充】
	// 某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，请设计一种求出每天热门Top100词汇的可行办法
	// = 哈希函数可以确保相同的内容一定被分到同样的位置, 因此利用哈希函数的性质可以进行分流.
	// 首先对每个url计算哈希, 然后取余控制映射范围, 然后写入到小文件中
	// 可能会出现碰撞的问题, 所以接下来针对每个小文件在进行分流
};

class HeapMerge {
	// 针对上面100亿个URL的问题, 如果要求出热门的Top100词汇的话, 首先还是利用哈希函数分流到文件中
	// 而后针对每个文件就可以利用哈希表统计词频得到每个文件的Top100词频
	// 接下来就是合并每个文件的Top100词频, 此时就可以利用堆来进行合并
	// 每个文件都会有一个大跟堆, 然后建立一个总堆, 大小为100
	// 每次从每个文件的大根堆中遍历得到最大的的堆顶, 然后pop这个堆顶, 加入到总堆中, 重复100次, 就可以得到答案
};


// 前面讲过了, 略. 主要针对黑名单和允许白名单被误报为黑名单的情况
class BloomFilter {
};

class BitMap {
	// 32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。
	// 可以使用最多1GB的内存，怎么找到所有未出现过的数？
	// 【进阶】
	// 内存限制为10MB，但是只用找到一个没出现过的数即可
	// = 基础逻辑是使用位图,
	// 40亿个数, 每个数字用一个位表示, 那么需要的40/8=5亿个bit, 需要5/8=0.625亿个字节
	// .625亿字节约等于500MB, 故基础问题使用位图即可解决
	// = 如果是10MB的内存的话, 那么每一个位映射一个区间
	// 假设一个int 32位, 即4字节, 那么10MB可以存储2560个int, 每个int统计对应区间的词频
	// 一个int就可以表示4294967296这么多个数, 所以经过第一轮遍历之后, 找到第一步不满4294967296的数字
	// 然后把对应的区间再分成2560份, 然后依次查找下去.
	// 直到找到这个数

	// 位图升级版
	// 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数，可以使用最多1GB的内存，找出所有出现了两次的数。
	// 位图只用一个位, 则只能判断某个数出现没出现, 如果要找出现两次乃至多次的话, 那么就可以针对每个数, 使用两个位来表示
	// 这样就可以表示某个数字出现了0, 1, 2, 3次
	// 因为使用两个位, 所以一次能表示的树的范围就少了一半, 因此把所有的数分成两部分

	// 【补充】
	// 可以使用最多10MB的内存，怎么找到这40亿个整数的中位数？

	// 还是分段, 针对每段统计数字, 然后就可以得知中位数落在某个区间, 然后再把这个范围划分, 再去找一编这个文件
};


int main(int argc, char *argv[]) {
	return 0;
}